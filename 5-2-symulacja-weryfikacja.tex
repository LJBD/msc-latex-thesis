\section{Symulacja i weryfikacja}
\label{sec:sym-wer}

Aby sprawdzić poprawność działania algorytmu optymalizacji dynamicznej, wykonano symulacje weryfikacyjne przy użyciu oprogramowania JModelica.org na wyższym poziomie aplikacji oraz środowiska MATLAB/Simulink na niższym.
W obu tych przypadkach błąd weryfikacji jest liczony według wzoru \ref{eq:ver-error}, gdzie $h_{i}^{s}(T)$ to wartość odpowiedniego poziomu po upływie czasu optymalnego uzyskana w symulacji, a $h_{i}^{f}$ to wartość docelowa tego poziomu.

\begin{equation}\label{eq:ver-error}
e_{wer} = \sum_{i=1}^{3} (h_{i}^{s}(T) - h_{i}^{f})^{2}
\end{equation}

Należy zwrócić uwagę na to, iż weryfikacja poprawności rozwiązania korzysta z innych danych, niż sprawdzenie dokładności rozwiązania opisane w sekcji \ref{sub:opt-dokladnosc}. Pierwsza procedura używa danych symulacyjnych uzyskanych po optymalizacji, a druga - danych pochodzących bezpośrednio z algorytmu optymalizacyjnego.

%-------------------------------------------------
\subsection{Przy użyciu pakietu JModelica.org}
\label{sub:sym-wer-jmodelica}

Po zakończeniu optymalizacji wyższy poziom aplikacji umożliwia przeprowadzenie symulacji weryfikacyjnej. Podaje się wtedy cały uzyskany wektor sterowania optymalnego (w postaci ,,surowej'' lub znormalizowanej) jako trajektorię wejściową do symulacji, a na koniec wylicza się błąd weryfikacji.

Poniżej przedstawiono 2 przykłady wykresów uzyskanych w czasie weryfikacji i porównano wartości błędów przy zastosowaniu sterowania w postaci ,,surowej'' oraz znormalizowanej.

\begin{figure}[htp]
    \centering
    \includegraphics{Grafika/plot_5_5_6-30_30_25-raw-350}
    \caption{Przykładowa weryfikacja rozwiązania przy użyciu pakietu JModelica.org. Źródło: własne.}
    \label{fig:plot556-303035-raw-350}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics{Grafika/plot_5_5_6-30_30_25-normalised-350}
    \caption{Przykładowa weryfikacja po normalizacji sterowania. Źródło: własne.}
    \label{fig:plot556-303035-normalised-350}
\end{figure}

Pierwszy przykład to napełnianie zbiorników od poziomów $h_{1}^{0} = 5 cm, h_{2}^{0} = 5 cm, h_{3}^{0} = 6 cm$ do poziomów $h_{1}^{f} = 30 cm, h_{2}^{f} = 30 cm, h_{3}^{f} = 25 cm$. Sterowanie w postaci z algorytmu optymalizacji osiągnęło wartość błędu weryfikacji $e_{wer}^{s} = 0,0002$, a po znormalizowaniu: $e_{wer}^{n} = 0.002$. W tym przypadku sterowanie w postaci ,,surowej'' (przedstawione na rys. \ref{fig:plot556-303035-raw-350}) wizualnie nie różni się bardzo od sterowania znormalizowanego (pokazanego na rys. \ref{fig:plot556-303035-normalised-350}), ale nawet taka niewielka różnica może prowadzić do zwiększenia się błędu weryfikacji o rząd wielkości. Jest to jednak również związane z tym, iż pierwszy błąd jest bardzo niewielki i w czasie wielu prób rzadko uzyskiwano tak niewielkie wartości. W tej optymalizacji użyto 350 elementów skończonych.

\begin{figure}[htp]
    \centering
    \includegraphics{Grafika/plot_30_30_30-20_25_20_raw_200}
    \caption{Druga przykładowa weryfikacja rozwiązania przy użyciu pakietu JModelica.org. Źródło: własne.}
    \label{fig:plot303030-202520raw200}
\end{figure}

\begin{figure}[htp]
    \centering
    \includegraphics{Grafika/plot_30_30_30-20_25_20_normalised_200}
    \caption{Druga przykładowa weryfikacja po normalizacji sterowania. Źródło: własne.}
    \label{fig:plot303030-202520normalised200}
\end{figure}

Drugi przykład to upuszczanie niewielkiej ilości wody ze zbiorników od poziomów $h_{1}^{0} = 30 cm, h_{2}^{0} = 30 cm, h_{3}^{0} = 30 cm$ do $h_{1}^{f} = 20 cm, h_{2}^{f} = 25 cm, h_{3}^{f} = 20 cm$. Sterowanie w postaci ,,surowej'' osiągnęło wartość błędu weryfikacji $e_{wer}^{s} = 0,007$, a w postaci znormalizowanej: $e_{wer}^{n} = 0.019$. Tutaj różnica między błędami jest mniejsza niż w poprzednim przypadku, mimo bardziej skomplikowanej struktury sterowania wyznaczonego przez algorytm optymalizacyjny (pokazanego na rys. \ref{fig:plot303030-202520raw200}). Sterowanie znormalizowane zaprezentowano na rys. \ref{fig:plot303030-202520normalised200}. W tej optymalizacji użyto 200 elementów skończonych, więc trzeba to wziąć pod uwagę, porównując wartości błędów między oboma opisanymi przypadkami.


\subsubsection{Wpływ liczby elementów metody elementów skończonych na rozwiązanie}

W związku z tym, że zastosowana metoda przynosiła dobre rezultaty, lecz wartości błędu weryfikacji były dosyć duże (rzędu jednej dziesiątej), podjęto próbę zwiększenia liczby elementów skończonych i przeprowadzenia ponownej optymalizacji i weryfikacji. Odkryto, iż istotnie ma ono wpływ na wartość błędów weryfikacji, ale również na czas obliczeń.

Przeprowadzono więc eksperyment, który miał pokazać ten wpływ liczby elementów skończonych na błędy weryfikacji dla sterowania ,,surowego'' i znormalizowanego oraz czas obliczeń. Przyjęto zmianę tej liczby w przedziale 50 do 500 z krokiem 50 tak, aby uzyskać 10 punktów pomiarowych.

W pierwszym przypadku skorzystano z napełniania zbiorników od poziomu $h_{1}^{0} = h_{2}^{0} = h_{3}^{0} = 1 cm$ do $h_{1}^{f} = h_{2}^{f} = h_{3}^{f} = 15 cm$. Uzyskane wyniki przedstawiono na rys. \ref{fig:elementsinfluence1-15_50-500}. Zauważono, iż:
\begin{itemize}
    \item różnica absolutna i relatywna między błędem weryfikacji dla sterowania ,,surowego'' i znormalizowanego jest największa w przypadku najmniejszej rozważanej liczby elementów,
    \item prędkość zmniejszania się błędów
    \item wartości czasów obliczeń rosną najprawdopodobniej wielomianowo,
    \item należy stosować wartości liczby elementów z przedziału między 200 a 350, gdyż tam występuje najlepszy stosunek czasu obliczeń do wartości błędów.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics{Grafika/elements_influence_1-15_50-500}
    \caption{Wpływ liczby elementów skończonych na rozwiązanie. Źródło: własne.}
    \label{fig:elementsinfluence1-15_50-500}
\end{figure}

Przeprowadzono drugi eksperyment dla innych danych w celu weryfikacji powyższych wniosków. Tym razem skorzystano z napełniania zbiorników od poziomu $h_{1}^{0} = h_{2}^{0} = h_{3}^{0} = 10 cm$ do $h_{1}^{f} = h_{2}^{f} = h_{3}^{f} = 20 cm$. Wyniki pokazano na rys. \ref{fig:elementsinfluence10-2050-500}. Tym razem zaobserwowano, iż:
\begin{itemize}
    \item wartości błędów są zależne od warunków zadania - w tym przypadku błędy były około 2 razy większe,
    \item czasy obliczeń nie zachowują się tak regularnie, jak w powyższym przypadku i osiągają wartości o rząd wielkości większe, a więc również silnie zależą od warunków zadania,
    \item potwierdziła się hipoteza, iż należy wybierać wartości liczby elementów między 200 a 350.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics{Grafika/elements_influence_10-20_50-500}
    \caption{Drugi przykład wpływu liczby elementów skończonych na rozwiązanie. Źródło: własne.}
    \label{fig:elementsinfluence10-2050-500}
\end{figure}

\subsubsection{Problemy z weryfikacją}

W przypadku niektórych wartości początkowych i końcowych oraz znalezionego dla nich sterowania optymalnego napotykano problem związany z tym, iż pakiet JModelica.org nie był w stanie obliczyć pochodnej jednego ze stanów w punkcie czasu niedługo po pierwszym przełączeniu. Rozwiązano go poprzez zwiększenie liczby elementów skończonych przy rozwiązywaniu danego zadania. Nie zaobserwowano takich problemów przy liczbie elementów powyżej 50.

%-------------------------------------------------
\subsection{Przy użyciu oprogramowania MATLAB/Simulink}
\label{sub:sym-wer-matlab}

%TODO: opisać okres próbkowania i inne ustawienia symulacji
%TODO: opisać wykresy i porównać z JModelicą

Symulację weryfikacyjną w programie MATLAB/Simulink przeprowadzono, łącząc oba poziomy aplikacji w całość i uruchamiając odpowiednie obliczenia. Zastosowano tam pewne uproszczenie: symulację uruchamiano dopiero po obliczeniu pierwszego sterowania optymalnego. Pokazano jednak, że w przy kolejnych optymalizacjach dokonywano ich w czasie trwania symulacji i niższy poziom aplikacji był w stanie przełączać się w czasie rzeczywistym między sterowaniem czasooptymalnym a liniowo-kwadratowym.

Poniżej pokazano dwa przykłady funnkcjonowania symulacji weryfikacyjnej niższego poziomu aplikacji.
W obu użyto metody Runge-Kutty 4 rzędu i stałego kroku o wartości 0.001 s. Dobrano taką metodę i wartość kroku czasowego ze względu na przewidywanie możliwości wykorzystania całej opisywanej aplikacji również z rzeczywistym układem zbiorników.
Symulacje przeprowadzono z nieskończonym czasem końcowym, ale prezentowane są tylko interesujące przedziały czasu.

\begin{figure}
    \centering
    \includegraphics[scale=0.5,angle=90]{Grafika/ext_ctrl_2_opts}
    \caption{Dwa procesy optymalizacji zweryfikowane w symulacji niższym poziomem aplikacji. Źródło: własne.}
    \label{fig:extctrl2opts}
\end{figure}

Pierwszy przykład jest pokazany na rys. \ref{fig:extctrl3opts}. Widoczne są tam 3 

\begin{figure}
    \centering
    \includegraphics[scale=0.5,angle=90]{Grafika/ext_ctrl_3_opts}
    \caption{Trzy procesy optymalizacji zweryfikowane w symulacji niższego poziomu aplikacji. Źródło: własne.}
    \label{fig:extctrl3opts}
\end{figure}
